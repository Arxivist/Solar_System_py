import Tkinter
import numpy as np
from visual import *

top = Tkinter.Tk()
GAMMA = 6.67408e-11
MASS_SUN = 1.989e30
# step for procedural analysis
DELTA = 10000

class planet:
    #
    # Orbital Elements:
    # 0 - a (Semimajor axis, Au)
    # 1 - e (eccentricity)
    # 2 - i (incluniation, Deg)
    # 3 - omega (longitude of ascending node, Deg)
    # 4 - w (argument of periapsis, Deg)
    # 5 - M0 (true anomoly at epoch, longitude Jan 2000, deg )
    # 6 - Mass
    def __init__(self, a, e, i, omega, w, M0, mass, name):
        self.a = a
        #e=0.6
        self.e = e
        #i = 10
        i = i * pi / 180
        self.i = i
        omega = omega * pi / 180
        self.omega = omega
        w = w * pi / 180
        self.w = w
        M0 = M0 * pi / 180
        self.M0 = M0
        self.mass = mass
        self.name = name
        self.radius = 3e9

        # find semiminor axis (b)
        b = a * sqrt(1 - pow(e, 2))

        #store self.b for later use
        self.b = b
        #find unit vector for ascending node
        u_an = vector(cos(omega),sin(omega),0)
        # find unit vector at max inclination
        u_hp = vector(cos(i) * cos(omega+pi/2),cos(i) * sin(omega+pi/2),sin(i))

        # find vector associated with semimajor axis
        va = vector(a * cos(i) * cos(w), a * cos(i) * sin(w), a * sin(i))
        ua = va / mag(va)

        # find unit vector associated with semiminor axis
        # note, fix this later to add inclination, currently slightly off
        vb = vector(b * cos(w - pi / 2), b * sin(w - pi / 2), 0)
        ub = vb / mag(vb)
        # find the centre of the focal point that the sun is at
        f1 = va-va*(1-e)
        f2 = va-va*(1+e)

        #correct for centering around f1
        va -= f1
        vb -= f1


        # calculate initial position
        self.pos = vector(-f1.x + a * cos(M0) * ua.x + b * sin(M0) * ub.x, -f1.y + a * cos(M0) * ua.y + b * sin(M0) * ub.y,
                          -f1.z + a * cos(M0) * ua.z + b * sin(M0) * ub.z)

        # calculate location of ascending node
        # ellipse has been rotated such that the ascending node is at 0
        self.asc_node = vector(-f1.x + a * cos(0) * u_an.x + b * sin(0) * u_hp.x,
                               -f1.y + a * cos(0) * u_an.y + b * sin(0) * u_hp.y,
                               -f1.z + a * cos(0) * u_an.z + b * sin(0) * u_hp.z)
        print self.asc_node

        # find zero
        self.zero = vector(-f1.x + a * cos(0) * ua.x + b * sin(0) * ub.x,
                               -f1.y + a * cos(0) * ua.y + b * sin(0) * ub.y,
                               -f1.z + a * cos(0) * ua.z + b * sin(0) * ub.z)
        self.z_label = label(pos=self.zero, text="zero")

        # Calculate the initial velocity
        # assumptions made: Orbiting Sun, with sun at centre of orbit
        # Calculate speed using v=sqrt(G*M*(2/r-1/a)
        speed = sqrt(GAMMA * MASS_SUN * (2 / mag(self.pos) - 1 / a))
        # velocity is perpindicular to orbital elliptacal. Take unit vector of velocity and multiply by speed to get initial velocity
        self.vel = norm(-a * sin(M0) * ua + b * cos(M0) * ub) * speed

        # display elements, nothing beyond her ein the init is required to run
        self.sphere = sphere(pos=self.pos, radius=self.radius, make_trail=True, color=color.gray(50))
        self.trail = curve(color=color.red)
        # add label
        self.label = label(pos=self.pos, text=name)
        t = np.linspace(0, 2 * pi, num=200)

        #display the orbit
        #needs modifications to account for inclination
        self.orbit = curve(x=-f1.x + a * cos(t) * ua.x + b * sin(t) * ub.x,
                           y=-f1.y + a * cos(t) * ua.y + b * sin(t) * ub.y,
                           z=-f1.z + a * cos(t) * ua.z + b * sin(t) * ub.z,
                           color=color.orange)

        # display modified orbit
        self.orbit = curve(x=-f1.x + a * cos(t) * u_an.x + b * sin(t) * u_hp.x,
                           y=-f1.y + a * cos(t) * u_an.y + b * sin(t) * u_hp.y,
                           z=-f1.z + a * cos(t) * u_an.z + b * sin(t) * u_hp.z,
                           color=color.green)

        self.ref_orbit = curve(x=-f1.x + a * cos(t) * ua.x + b * sin(t) * ub.x,
                           y=-f1.y + a * cos(t) * ua.y + b * sin(t) * ub.y,
                           z=-f1.z,
                           color=color.white)

        # above equations have transformed f1 to (0,0,0) anf f2 to 2*f2, need to reflect that.
        f1 = (0,0,0)
        f2 = 2*f2

        self.f1_label = label(pos=f1, text="f1")
        self.f2_label = label(pos=f2, text="f2")
        self.f2_point = points(pos=f2, size=5, color=color.green)
        self.a_disp = curve(pos=[(f2/2),va],color=color.green)
        self.a_point = points(pos=va, size = 5, color = color.green)
        self.a_label = label(pos=((va+f2/2)/2), text="a")

        #display semi-minor axis
        self.b_disp = curve(pos=[(f2/2),vb],color=color.blue)
        self.b_label = label(pos=(vb+f2/2)/2, text="b")

        #display ascending node
        self.asc_node_label = label(pos=self.asc_node, text="A_n")
        self.asc_node_point = points(pos=self.asc_node, size=10, color=color.green)

        # display axis
        self.b_disp = curve(pos=[f1,(1e11,0,0)], color=color.white)
        self.b_label = label(pos=(1e11,0,0), text="x")

        self.b_disp = curve(pos=[f1, (0,1e11,  0)], color=color.white)
        self.b_label = label(pos=(0,1e11,  0), text="y")

        self.b_disp = curve(pos=[f1, ( 0, 0,1e11)], color=color.white)
        self.b_label = label(pos=(0, 0,1e11), text="z")


scene = display(x=50, y=30, width=1400, height=1000)
Sun = sphere(pos=(0, 0, 0), radius=1e10, color=color.orange, material=materials.emissive)
lPlanets = []
lPlanets.append(planet(0.38709893 * 1.496e+11, 0.20563069, 7.00487, 48.33167, 77.45645, 252.25084, 3.285e23, 'Mercury'))


def helloCallBack():
    lPlanets[0].sphere.color = color.red

def mv_earth ():
    x=0
    # use newtons equation for gravity, F = G*M1*M2/r^2
    F = -1 * norm(lPlanets[x].pos) * (GAMMA * MASS_SUN * lPlanets[x].mass / (pow(mag(lPlanets[x].pos), 2)))
    # use F = M*A to find accelelration of planet
    A = F / lPlanets[x].mass

    # symplectic Euler
    lPlanets[x].vel += DELTA * A
    lPlanets[x].pos += DELTA * lPlanets[x].vel

    # display info
    lPlanets[x].sphere.pos = lPlanets[x].pos
    lPlanets[x].trail.append(pos=lPlanets[x].sphere.pos)

    # move labels
    lPlanets[x].label.pos = lPlanets[x].pos
    top.after(50,mv_earth)



# layout of GUI
B = Tkinter.Button(top, text ="Hello", command = helloCallBack)
B.pack()



LF = Tkinter.LabelFrame(top, height = 300, width = 300)
LF.pack()



top.after(0, mv_earth)
top.mainloop()



